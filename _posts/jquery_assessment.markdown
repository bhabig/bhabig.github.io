---
layout: post
title:  "jQuery and AJAX are the Best"
date:   2017-03-17 13:04:03 -0400
---

To start my jQuery project, I was asked display a collection of objects on the page without reload. Thanks to the magic of jQuery and AJAX, and the awesome way the READmes in this course are written, this was a breeze! We learned how to set up a click event on any DOM element easily by setting up a document.ready function and then a click function on the selected element. For this I chose to set up a click for the user's recipe collection button.

Once I had that function set up, I had to write my get request. This was slightly tedious, because you need the user's ID for the request url. The reason this was tedious is that the $.get() function needs a URL like 'users/:id' - yet the object represented by 'this' at the time of click, which is given to this function responsible for making the resquest, only has the full HTML, which contains the unnecessary bits about the localhost, etc. and also ends in '/recipes'. The challenge was to find a reliable way to splice out only the relevant pieces (compiled further by the fact that a user's id could be 1, 2, 3, etc. digits long!). The solution I can up with was to split the address on '/'s, this way I wound up with 'users' as the fourth element of the collection every time and then the ID was the fifth. this way i could manually construct my url: `'/' + splitHTML[3] + '/' + splitHTML[4] + '.json'`.

Inside this request's response function, where the JSON of the collection retrieved by the request is given back to you,
I created a new recipe object built from a recipe constructor function, which includes 3 functions for taking the right recipe traits like name, photo url, user_id and recipe_id, etc. and placing them into the proper HTML elements. These HTML elements were then appended to a <li></li> which was finally appended to the empty <ul> on the user's show page!

Next I made it so that if you click on the link to see the full recipe show page on any of the li's created above, you will be taken to the recipe's show page you clicked on, but then I built the functionality to click 'next recipe' and see the next recipe in that user's collection of recipes without reloading the page. I called this the recipe carousel. It was a monumental challenge building this out.

To start, I gave the 'next recipe' button 2 attributes to use in javascript - data-user-id, and data-recipe-id. these were set to the values of the current user's id and the current recipe's id provided initially by the recipes#show action. Next I set up a click event function in my corresponding JS file. I then had to use these hidden id's to capture the current user's id in a global var and same for the current recipe. From here I mad a get request to the user's show action which return serialized json for that user with their collection of recipes and recipe_ingredients nested in the object. From this, the user's recipe ids were pushed into a global array variable. Then the index adjustment function was fired with this recipe id collection as the argument. The purpose of this function is to take the initial recipe ID and find the ID of the next recipe in the array. This was a challenge and then some bc of the difficulty of keeping track of and accessing the correct ids from the array every time. I wound up using the indexOf function called on the array of recipe ids using the data-recipe-id attribute of the 'next recipe' button to set an initial 'nextId' variable value if it was undefined, from that point, nextId was either set back to 0 if the index of the current id was the last index of the array, otherwise the value of nextId was incremented by 1. nextId was an arbitrary counter used to represent the INDEX of the next id in the recipes array from the previous step. After this is done, the 'recipeId' variable was set like so: recipeId = recipeIdCollection[nextId];

All of the above allowed me to make my get request to the proper recipe - the request url had to be formatted like '/users/:user_id/recipes/:recipes_id.json'. Finally, it was just necessary to tinker in chrome console for awhile to figure out how to format the response of the request properly and append! This included a loop to append all of the nested ingredient's info in a <ul>.

Finally, to make a post request I built out a 'like' feature. the like is a join between a user and a recipe, and is created or updated by clicking the button. A click event triggers events that change the status of the like object's status to the opposite of what it currently is every time there is a click. The status attribute is used to dictate the appropriate id assigned to the div. There are 2 possible id's in the CSS file, so depending on whether the status was true or false, one id name or the other was given. One for a liked recipe and one for a not-yet-or-unliked recipe. The appropriate text was also given to this. Once this was built out for 1 recipe, I took on the challenge of making this work throughout the whole recipe show carousel mentioned above. This was the hardest part, bc of having to update and pay attention to so many ID values, but in the end paid off in spades!

All in all, AJAX and jQuery click for me, but there can be times where it can get unimaginably tedious and this project helped me notice times where that happens and ways to deal with it or prevent it in the first place. I am very proud of this app, even though its becoming a hodge podge of sorts, for the functionality I have been able to build so far. I certainly don't believe I have coded as conventionally as possible, however, and aim to take my working code and make it more concise and 'standard'.
